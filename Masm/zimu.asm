DATAS SEGMENT
    ;此处输入数据段代码
    CHAR DB 20 DUP(0),'$'
    CHARS DB 20 DUP(0),'$'
    COUNT DB 20 DUP(0),'$'
    CRLF DB 0AH,0DH,'$'
    SPACE DB 0,'$'
    SHURU DB 'Please input 20 char:$'
DATAS ENDS

STACKS SEGMENT
	DB 8 DUP(0)
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    
    MOV DX,OFFSET SHURU
	MOV AH,09H
	INT 21H
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;输入字符串到char中
    MOV BX,0
	MOV CX,20
INPUT:
	MOV AH,01H
	INT 21H
	MOV CHAR[BX],AL
	INC BX
	LOOP INPUT
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;外循环依次取出CHAR里的字母，与0比较
	MOV BX,0
	MOV DI,0
	MOV COUNT[0],1
	MOV CX,20
WAI:PUSH CX
	MOV AX,0
	CMP CHAR[BX],AL
	JZ	NEXT			;是0就跳下一次循环
	MOV AL,CHAR[BX]		;将CHAR[BX]放入AL中
	MOV SI,1
	MOV CX,20
NEI:					;不是0就与自己以下的字母比较
	MOV DL,[BX+SI]
	MOV CHARS[DI],AL
	CMP AL,DL
	JNZ L				;不相等，和下一个字母比较			
						
	MOV CHAR[BX+SI],0	;相等，置，并且计数DH加一
	;INC DH
	INC COUNT[DI]
L:	INC SI
	LOOP NEI
	INC DI	
NEXT:
	INC BX
	POP CX
	LOOP WAI
	
	MOV DX,OFFSET CRLF
	MOV AH,09H
	INT 21H
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;将COUNT里的值一次与987654321比较
;有相等的的输出COUNT[SI]和CHAR[SI]
	MOV BL,10	
	MOV CX,10
R:	PUSH CX
	MOV SI,0
	MOV CX,10
S:	CMP BL,COUNT[SI]
	JNZ NEXT1
	MOV DL,COUNT[SI]	;输出数字
	ADD DL,30H
	MOV AH,02H
	INT 21H
	
	MOV DX,OFFSET SPACE
	MOV AH,09H
	INT 21H
	
	MOV DL,CHARS[SI]	;输出字母
	MOV AH,02H
	INT 21H
	MOV DX,OFFSET CRLF
	MOV AH,09H
	INT 21H
NEXT1:
	INC SI
	LOOP S
	POP CX
	DEC BL
	LOOP R
    MOV AH,4CH
    INT 21H
CODES ENDS
    END START

